# Default user/project configuration file, used as a template to validate all other user/project configuration files
# SBEMimage version 2020.07
#
# DO NOT EDIT this file unless you know what you are doing!
# Comments refer to the key in the following line, with the format: explanation of the key; module in SBEMimage where the key is loaded as an attribute

[sys]
# system configuration file associated with this user/project configuration file; main_controls (read only)
sys_config_file = system.cfg
# True if simulation mode active (no connection to SEM/microtome); main_controls
simulation_mode = True
# True if microtome to be used; main_controls
use_microtome = True
# mirror drive (for mirroring acquired data, must be a drive letter [X:], can point to a network drive); acquisition
mirror_drive = Z:
# True if mirror drive to be used; acquisition
use_mirror_drive = False
# True if Variable Pressure (Low Vacuum) option installed; main_controls
vp_installed = False
# True if plasma cleaner ('plc'; = downstream asher) installed; main_controls (read only)
plc_installed = False
# serial port used by plasma cleaner; main_controls (read only), launches plasma_cleaner
plc_com_port = COM5
# email account used for remote monitoring and commands (password is provided by user at runtime, not stored anywhere); notifications (read only)
email_account = account_name@server.ch
# SMTP server for the email account above; notifications (read only)
email_smtp = smtp.server.ch
# IMAP server for the email account above; notifications (read only)
email_imap = imap.server.ch
# URL of the server to which metadata is being sent while an acquisition is running (for example, VIME Server); notifications
metadata_server_url = https://remote.server.ch
# email of the administrator of the metadata server (for alerts and remote control); notifications
metadata_server_admin = account_name@server.ch
# name of the project (for metadata server [VIME]); acquisition
metadata_project_name = test
# True if metadata to be send to metadata server during acquisition; acquisition
send_metadata = False
# True if MagC mode (wafer acquisition mode) active; main_controls
magc_mode = False

[sem]
# name of the SEM; sem_control
device = ZEISS Merlin
# target EHT (= high voltage) in kV; sem_control
eht = 1.5
# target beam current in pA; sem_control
beam_current = 300
# target aperture size in Î¼m; sem_control
aperture_size = 30.0
# default dwell time for single frames in microseconds; sem_control
grab_frame_dwell_time = 0.8
# default pixel size for single frames in nanometres; sem_control
grab_frame_pixel_size = 10.0
# default frame size selector for single frames; sem_control
grab_frame_size_selector = 4
# default frame size in pixels for single frames (set according to grab_frame_size_selector); sem_control
grab_frame_size_xy = [4096, 3072]
# True if auto beam blank active; sem_control
auto_beam_blank = True
# BSE detector contrast setting; sem_control
bsd_contrast = 5.0
# BSE detector brightness setting; sem_control
bsd_brightness = 1.0
# BSE detector bias voltage; sem_control
bsd_bias = -6
# speed of X motor in microns/second; sem_control
motor_speed_x = 1000
# speed of Y motor in microns/second; sem_control
motor_speed_y = 1000
# waiting time in seconds after each stage move before acquiring new image; sem_control
stage_move_wait_interval = 0.5
# waiting time in seconds between checking stage status; sem_control
stage_move_check_interval = 0.2
# X motor range minimum value in micrometres; sem_control
stage_min_x = 0
# X motor range maximum value in micrometres; sem_control
stage_max_x = 130000
# Y motor range minimum value in micrometres; sem_control
stage_min_y = 0
# Y motor range maximum value in micrometres; sem_control
stage_max_y = 130000
# calibration scale factor for X axis; coordinate_system
stage_scale_factor_x = 1.0
# calibration scale factor for Y axis; coordinate_system
stage_scale_factor_y = 1.0
# calibration: rotation angle for X axis; coordinate_system
stage_rotation_angle_x = 0.0
# calibration: rotation angle for Y axis; coordinate_system
stage_rotation_angle_y = 0.0

[microtome]
# name of the microtome; microtome_control
device = Gatan 3View
# knife cut speed (slow setting) in microns/second; microtome_control
knife_cut_speed = 300
# knife cut speed (fast setting) in microns/second; microtome_control
knife_fast_speed = 1500
# knife retract speed in microns/second; microtome_control
knife_retract_speed = 900
# start of the cutting window, position in microns; microtome_control
knife_cut_start = 1500
# end of the cutting window, position in microns; microtome_control
knife_cut_end = 0
# True if knife oscillation active; microtome_control
knife_oscillation = True
# amplitude of knife oscillation in nm; microtome_control
knife_osc_amplitude = 100
# knife oscillation frequency in Hz; microtome_control
knife_osc_frequency = 25000
# duration of a full cut cycle (near, cut, clear) in seconds; microtome_control
full_cut_duration = 16
# Z distance sample is retracted during a sweep, in nanometres: microtome_control (currently read only)
sweep_distance = 70
# X stage motor speed in microns/second; microtome_control
motor_speed_x = 62.5
# Y stage motor speed in microns/second; microtome_control
motor_speed_y = 52.63
# waiting time in seconds after each stage move before acquiring new image; microtome_control
stage_move_wait_interval = 0.5
# X motor range minimum value in micrometres; microtome_control
stage_min_x = -1000
# X motor range maximum value in micrometres; microtome_control
stage_max_x = 1000
# Y motor range minimum value in micrometres; microtome_control
stage_min_y = -800
# Y motor range maximum value in micrometres; microtome_control
stage_max_y = 800
# calibration scale factor for X axis; coordinate_system
stage_scale_factor_x = 1.0000
# calibration scale factor for Y axis; coordinate_system
stage_scale_factor_y = 1.0000
# calibration: rotation angle for X axis; coordinate_system
stage_rotation_angle_x = 0.7000
# calibration: rotation angle for Y axis; coordinate_system
stage_rotation_angle_y = 0.7000
# last known Z position in micrometres; microtome_control
last_known_z = None

[gcib]
ftdi_serial = 0
# XYZ stage coordinates, translation and rotation angle in degree
xyzt_milling = [[0, 0, 0, 0, 0]]
# duration given in Hayworth et al., 2019 in Nat. Methods
# GCIB params: 32nA, Ar2000, 10kV
# 8 mm**2 area, 30 deg glancing angle, 12nm removal per image
mill_cycle = 360
continuous_rot = 0

[acq]
# base directory of the current acquisition; acquisition
base_dir = C:\temp\sbemimage_test
# target number of slices to be acquired; acquisition
number_slices = 1000
# slice counter = current slice index; acquisition
slice_counter = 0
# cutting thickness in nanometres; acquisition
slice_thickness = 50
# total Z depth of sample removed by microtome since last reset, in micrometres; acquisition
total_z_diff = 0.0
# True if acquisition paused; acquisition
paused = False
# True if acquisition interrupted; acquisition
interrupted = False
# position of interruption [grid_index, tile_index]; acquisition
interrupted_at = []
# tiles already acquired (in grid where interruption occured) before the interruption occured; acquisition
tiles_acquired = []
# grids already (completely) acquired before interruption occured; acquisition
grids_acquired = []
# True if overview images to be acquired during stack acquisition; acquisition
take_overviews = True
# True if images to be monitored (threshold tests); acquisition
monitor_images = False
# True if email monitoring to be used; acquisition
use_email_monitoring = False
# True if autofocus to be used; acquisition
use_autofocus = False
# True if debris detection and removal to be used; acquisition
use_debris_detection = True
# True if 'Ask User Mode' active; acquisition
ask_user = False
# True if EHT (= high voltage) to be switched off after stack is completed; acquisition
eht_off_after_stack = False

[grids]
# total number of configured grids; grid_manager
number_grids = 1
# list indicating whether grid at index position is active (1) or inactive (0); grid_manager
grid_active = [1]
# list of grid origins (= tile 0 centre coordinates in each grid) in stage coordinates; grid_manager
origin_sx_sy = [[-20.000, -20.000]]
# list of grid rotation angles in degrees; grid_manager
rotation = [0]
# list of grid sizes (rows x columns); grid_manager
size = [[4, 4]]
# left-right and top-bottom overlap between neighbouring tiles in pixels; grid_manager
overlap = [200]
# number of pixels by which every other row of the grid is shifted; grid_manager
row_shift = [0]
# list of active tiles in each grid; grid_manager
active_tiles = [[6, 5, 9, 10]]
# list of tile sizes (pixel width x pixel height); grid_manager
tile_size = [[4096, 3072]]
# list of tile size selectors (determine tile sizes above); grid_manager
tile_size_selector = [4]
# list of pixel sizes in nm; grid_manager
pixel_size = [10.0]
# list of dwell times in microseconds; grid_manager
dwell_time = [0.8]
# list of dwell time selectors (determine dwell times above); grid_manager
dwell_time_selector = [4]
# list of colours in which the grid lines of each grid are drawn in the Viewport; grid_manager
display_colour = [0]
# list of acquisition intervals (1: acquire on every slice; 2: acquire on every other slice; N: acquire on every Nth slice); grid_manager
acq_interval = [1]
# list of acquisition interval offsets: grid acquired if (slice_counter - acq_interval_offset) mod acq_interval == 0; grid_manager
acq_interval_offset = [0]
# list of focus parameters (working distance [wd], X stigmation, Y stigmation); grid_manager
wd_stig_xy = [[0, 0, 0]]
# list indicating whether grid at index position is set to use a working distance gradient; grid_manager
use_wd_gradient = [0]
# list of user-selected tiles to calculate working distance gradients; grid_manager
wd_gradient_ref_tiles = [[-1, -1, -1]]
# list of working distance gradient parameters [working distance at origin, x slope, y slope]
wd_gradient_params = [[0, 0, 0]]
# list of individually set focus parameters [working distance, X stigmataion, Y stigmation], dict keys are in the format: grid_number.tile_number; grid_manager
wd_stig_params = {}

[overviews]
# total number of configured overview images; overview_manager
number_ov = 1
# list indicating whether overview at index position is active (1) or inactive (0); overview_manager
ov_active = [1]
# list of overview centres in stage coordinates; overview_manager
ov_centre_sx_sy = [[0, 0]]
# list of overview rotation angles in degrees; overview_manager
ov_rotation = [0]
# list of overview image sizes (pixel width x pixel height); overview_manager
ov_size = [[2048, 1536]]
# list of size selectors (determine frame sizes in pixels above); overview_manager
ov_size_selector = [2]
# list of pixel sizes in nm; overview_manager
ov_pixel_size = [155.0]
# list of dwell times in microseconds; overview_manager
ov_dwell_time = [0.8]
# list of dwell time selectors (determine dwell times above); overview_manager
ov_dwell_time_selector = [4]
# list of focus parameters (working distance [wd], X stigmation, Y stigmation); overview_manager
ov_wd_stig_xy = [[0, 0, 0]]
# list of acquisition intervals (1: acquire on every slice; 2: acquire on every other slice; N: acquire on every Nth slice); overview_manager
ov_acq_interval = [1]
# list of acquisition interval offsets: overview acquired if (slice_counter - acq_interval_offset) mod acq_interval == 0; overview_manager
ov_acq_interval_offset = [0]
# paths to most recently acquired overview images that are shown in the Viewport; overview_manager
ov_viewport_images = [""]
# stage coordinates of the stub overview centre; overview_manager
stub_ov_centre_sx_sy = [0, 0]
# Size of the grid [rows, cols] used for the stub overview; overview_manager
stub_ov_grid_size = [5, 4]
# left-right and top-bottom overlap in pixels between neighbouring stub overview tiles; overview_manager
stub_ov_overlap = 32
# frame size selector for stub overview tiles; overview_manager
stub_ov_frame_size_selector = 0
# pixel size in nm for stub overview tiles; overview_manager
stub_ov_pixel_size = 372
# dwell time selector for stub overview tiles; overview_manager
stub_ov_dwell_time_selector = 4
# path to most recently acquired stub overview image, displayed in the Viewport; overview_manager
stub_ov_viewport_image =

[imported]
# total number of imported images; imported_img
number_imported = 0
# list of paths to imported images (stored in 'imported' subdirectory of base directory); imported_img
image_src = []
# list of description strings; imported_img
description = []
# list of imported image centre coordinates; imported_img
centre_sx_sy = []
# list of rotation angles in degree; imported_img
rotation = []
# list of sizes [pixel width, pixel height]; imported_img
size = []
# list of pixel sizes in nm; imported_img
pixel_size = []
# list of tranparency values in per cent (100: fully transparent, image invisible; 0: max. opacity); imported_img
transparency = []

[viewport]
# centre coordinates of current workspace area that is visible in the Viewport (vp), in SEM coordinates; coordinate_system
vp_centre_dx_dy = [0, 0]
# current Viewport scale factor; coordinate_system
vp_scale = 0.230
# grid(s) currently selected for display in Viewport (-1: all grids visible); viewport
vp_current_grid = -1
# overview(s) currently selected for display in Viewport (-1: all overviews visible); viewport
vp_current_ov = -1
# current preview mode (0: no tile previews shown; 1..3: tile previews shown with different options); viewport
vp_tile_preview_mode = 0
# True if stub overview to be shown in Viewport; viewport
show_stub_ov = False
# True if imported images to be shown in Viewport; viewport
show_imported = False
# True if axes to be shown in Viewport; viewport
show_axes = True
# True if text labels to be shown in Viewport; viewport
show_labels = True
# True if native resolution display to be enforced in Slice-by-Slice Viewer; viewport
show_native_resolution = True
# True if saturated pixels to be displayed in blue/red in Slice-by-Slice Viewer; viewport
show_saturated_pixels = False
# grid currently selected in Slice-by-Slice Viewer (sv); viewport
sv_current_grid = 0
# tile currently selected in Slice-by-Slice Viewer; viewport
sv_current_tile = 1
# overview image currently selected in Slice-by-Slice Viewer; viewport
sv_current_ov = -1
# current scale factor for tiles in Slice-by-Slice Viewer; viewport
sv_scale_tile = 100.0
# current scale factor for overviews in Slice-by-Slice Viewer; viewport
sv_scale_ov = 6.500
# X pixel offset for tile display in Slice-by-Slice Viewer; viewport
sv_offset_x_tile = -2000
# Y pixel offset for tile display in Slice-by-Slice Viewer; viewport
sv_offset_y_tile = -1500
# X pixel offset for overview display in Slice-by-Slice Viewer; viewport
sv_offset_x_ov = -450
# Y pixel offset for overview display in Slice-by-Slice Viewer; viewport
sv_offset_y_ov = -330
# grid currently selected in monitoring ('m') tab (histogram/reslice/plots); viewport
m_current_grid = 0
# tile currently selected in monitoring tab; viewport
m_current_tile = -1
# overview image currently selected in monitoring tab; viewport
m_current_ov = -1

[monitoring]
# primary email address for monitoring (status reports and error notifications); notifications
user_email = primary_user@server.ch
# secondary (optional) email address for monitoring; notifications
cc_user_email =
# slice interval for sending status report; acquisition
report_interval = 100
# list of overview images to be sent in attachment in status report; notifications
report_ov_list = [0]
# list of tiles to be sent in status report; notifications
report_tile_list = [""]
# line number limit of log in Main Controls windows (most recent lines); main_controls (read only)
max_log_line_count = 2000
# True if main log to be sent in status report; notifications
send_logfile = True
# True if debris and error logs to be sent in status report; notifications
send_additional_logs = True
# True if viewport screenshot to be sent in status report; notifications
send_viewport_screenshot = True
# True if overview(s) in report_ov_list to be sent in status report; notifications
send_ov = True
# True if tiles in report_tile_list to be sent in status report; notifications
send_tiles = False
# True if reslices of overviews in report_ov_list to be sent in status report; notifications
send_ov_reslices = False
# True if reslices of tiles in report_tile_list to be sent in status report; notifications
send_tile_reslices = False
# True if remote commands (sent by user via email to SBEMimage) are enabled; notifications
remote_commands_enabled = False
# slice interval for checking for remote commands; acquisition
remote_check_interval = 10
# lower limit of the histogram mean for image monitoring; image_inspector
mean_lower_limit = 65
# upper limit of the histogram mean for image monitoring; image_inspector
mean_upper_limit = 195
# lower limit of the histogram standard deviation for image monitoring; image_inspector
stddev_lower_limit = 5
# upper limit of the histogram standard deviation for image monitoring; image_inspector
stddev_upper_limit = 105
# list of tiles to be monitored (format: grid_index.tile_index); image_inspector
tile_list = [""]
# threshold for tile-by-tile mean comparisons; image_inspector
tile_mean_threshold = 1.0
# threshold for tile-by_tile standard deviation comparisons; image_inspector
tile_stddev_threshold = 0.5

[debris]
# choice of detection method (0: default quadrant comparison; 1: histogram count of image diff); image_inspector
detection_method = 0
# list of debris detection areas for the overviews [upper_left_x, upper_left_y, lower_right_x, lower_right_y]; overview_manager
detection_area = [[941, 818, 1497, 1242]]
# True if debris detection area(s) to be displayed in Viewport (dashed blue rectangles); overview_manager
show_detection_area = True
# True if two previous overviews to be used for debris detection; currently not used
use_two_previous = False
# minimum quadrant area in pixels for method 0; image_inspector
min_quadrant_area = 80000
# threshold for the difference in histogram mean (method 0); image_inspector
mean_diff_threshold = 3.0
# threshold for the difference in standard deviation (method 0); image_inspector
stddev_diff_threshold = 1.0
# threshold for method 1; image_inspector
image_diff_threshold = 600
# median filter kernel size for preprocessing image for method 1; image_inspector
median_filter_kernel_size = 7
# histogram cutoff for method 1; image_inspector
image_diff_hist_lower_limit = 30
# threshold for method 2; image_inspector
histogram_diff_threshold = 30000
# True if debris detection area is determined automatically based on active tiles; overview_manager
auto_detection_area = True
# margin in pixels around automatically determined debris detection area; overview_manager
auto_area_margin = 20
# maximum number of sweeps if debris is detected; acquisition
max_number_sweeps = 3
# True if acquisition automatically continues after max_number_sweeps reached; acquisition
continue_after_max_sweeps = False

[autofocus]
# autofocus method: 0 for SmartSEM autofocus, 1 for heuristic autofocus, 2 for (manual) focus tracking, 3 for mapfost; autofocus
method = 0
# list of autofocus reference tiles, format: grid_index.tile_index; grid_manager
ref_tiles = ["0.0"]
# choice of tracking mode: 0 for 'track selected, approx. others', 1 for 'average selected', 2 for 'track all'; autofocus
tracking_mode = 0
# maximum allowed difference in focus parameters after autofocus adjustment; autofocus
max_wd_stig_diff = [1e-05, 1.0, 1.0]
# autofocus interval (every N slices); autofocus
interval = 50
# delay (in number of slices) of autostig procedure after autofocus procedure; autofocus
autostig_delay = 5
# pixel size in nm for SmartSEM autofocus; autofocus
pixel_size = 10.0
# heuristic deltas (deliberate alternating changes to focus parameters for heuristic autofocus); autofocus
heuristic_deltas = [8e-07, 0.05, 0.05]
# calibration parameters for heuristic autofocus; autofocus
heuristic_calibration = [0.05, 0.2, 0.2]
# calibration for stigmation correction for heuristic autofocus; autofocus
heuristic_rot_scale = [6.021, 1.0]
# electron probe convergence angle needed for mapfost calibration
mapfost_probe_convergence_angle = 0.003
# the angle between the stigmator axes and the imaging axes, used in mapfost calibration
mapfost_astig_rotation_deg = 0.
# astigmatism scaling parameter which converts the um estimations to the microscope stigmator units in %
mapfost_astig_scaling = [1.,1.]
# the magnitude of the perturbation used (ref. MAPFoSt, Binding 2013). The WD is perturbed by this value in both directions
mapfost_wd_perturbations = 4
# the maximum number of cycles the mapfost will run in case convergence is not achieved earlier
mapfost_maximum_iterations = 8
# the pixel dwell time for calibration and mapfost routine (a high dwell time (like 0.8) recommended during calibration)
mapfost_dwell_time = 0.8
# the threshold aberration in um for reaching convergence (norm2([defocus, ax, ay]))
mapfost_convergence_threshold_um = 0.2
